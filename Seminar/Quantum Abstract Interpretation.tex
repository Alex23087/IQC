\documentclass[11pt,svgnames,smaller,aspectratio=43,english]{beamer}

\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usetikzlibrary{graphs,graphdrawing,arrows.meta,positioning,quotes,external,chains,graphs.standard}
\tikzexternalize[prefix=tikzfigures/]
\usegdlibrary{trees}
\usepackage{xcolor}
\usepackage{subfig}
\usepackage{braket}

\usetheme{UniPi}
\setbeamercovered{transparent=0}
\setbeamersize{text margin left=15mm,text margin right=15mm}
\setbeamertemplate{itemize subitem}{-}
\uselanguage{english}
\languagepath{english}

\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
\newcommand{\tensor}{\otimes}

\newcommand{\bunder}[2]{\underbrace{#1}_{\text{\scriptsize\tabular[t]{@{}c@{}}#2\endtabular}}}




\title{Quantum Abstract Interpretation}
\author{Alessandro Scala}
\institute[Università di Pisa]{Università di Pisa\\Dipartimento di Informatica}
\date{Pisa, 24 Luglio 2023}
\extra{Seminar for the \textbf{Introduction to Quantum Computing} course}

\usepackage{transparent}
\mode<presentation>

\begin{document}

\begin{frame} 
	\titlepage
\end{frame}
\logo{\transparent{0.2}\includegraphics[height=2cm]{images/cherubino}}



% ------------------ CHANGE FROM HERE ------------------

\begin{frame}{Roadmap}
	\tableofcontents
\end{frame}

\begin{frame}{Introduction}
	As quantum computing advances, we would like to have some means to prove correctness properties on quantum programs, \emph{especially} since quantum programming is counterintuitive.\\
\end{frame}

\begin{frame}<1-4>[label=reasons]{Reasons}
	The naive way to check properties of a program is to run it and \textbf<2->{observe} its behaviour.\\\;\\
	\pause
	\alert{We \textbf{cannot observe} the state of a quantum program!}\\\;\\
	\pause
	Could \textbf{simulation} on a classical machine solve this issue?\\\;\\
	\pause
	\alert{No: \textbf{exponential} space and time cost.}\\\;\\\;\\
	\pause
	\begin{center}
		\large \color{blue} Solution: abstract interpretation
	\end{center}
\end{frame}

\begin{frame}[noframenumbering]{Example}
	\only<1>{
		\begin{gather*}
			n_{qubits} = 1\\\;\\
			\ket{0}\bra{0}\\\;\\
			\begin{pmatrix}
				1 & 0\\0 & 0
			\end{pmatrix}\\\;\\
			2^2 = 4 \text{ complex numbers}
		\end{gather*}
	}
	\only<2>{
		\begin{gather*}
			n_{qubits} = 2\\\;\\
			\ket{00}\bra{00}\\\;\\
			\begin{pmatrix}
				1 & 0 & 0 & 0 \\0 & 0 & 0 & 0 \\0 & 0 & 0 & 0 \\0 & 0 & 0 & 0	
			\end{pmatrix}\\\;\\
			2^4 = 16 \text{ complex numbers}
		\end{gather*}
	}

	\only<3>{
		\setcounter{MaxMatrixCols}{8}
		\begin{gather*}
			n_{qubits} = 3\\\;\\
			\ket{000}\bra{000}\\\;\\
			\begin{pmatrix}
				1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
				0& 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
				0& 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
				0& 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
				0& 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
				0& 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
				0& 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
				0& 0 & 0 & 0 & 0 & 0 & 0 & 0
			\end{pmatrix}\\\;\\
			2^6 = 64 \text{ complex numbers}
		\end{gather*}
	}

	\only<4->{
		\begin{gather*}
			n_{qubits} = 300\\\;\\
			\ket{0}^{\tensor_{300}}\bra{0}^{\tensor_{300}}\\\;\\
			\only<4>{?????\\\;\\}
			\only<5->{2^{600} = 41495155688809929585124078636911611510124462322424368\\9999
			56573296906528114129081463997070489471037942881978866113\\007
			891823951510754117753078868748341139636870611818034015095\\23685376\\\;\\
			\text{\alert{Bigger than the number of atoms in the universe.}}}
		\end{gather*}
	}
\end{frame}

\againframe<4->[noframenumbering]{reasons}

\begin{frame}{Ingredients}
	\begin{itemize}
		\item Abstract domain
		\begin{itemize}
			\item Abstraction function
			\item Concretization function
			\item Abstract operations
		\end{itemize}
		\item Assertions
	\end{itemize}
\end{frame}

\section{Preliminaries}
\subsection{Density Matrix}
\begin{frame}{Density Matrix}
	Instead of dealing with a state $\ket{\phi}$ in vector form, we use its \emph{density matrix}:

	\begin{columns}
		\begin{column}[T]{0.35\textwidth}
			\begin{equation*}
				\rho_\phi = \ket{\phi}\bra{\phi} \text{ (For a pure state)}		
			\end{equation*}
		\end{column}
		\begin{column}[T]{0.5\textwidth}
			\begin{itemize}
				\item positive semi-definite
				\item $Tr(\rho) = 1$
				\item projection ($P = P^\dagger = P^2$)
			\end{itemize}
		\end{column}
	\end{columns}

	\vspace*{1em}

	\uncover<2->{
		{\large \color{blue} Example:}
		\begin{align*}
			\ket{\beta_{00}} &= \frac{\ket{00} + \ket{11}}{\sqrt{2}}\\
			\rho_{\beta_{00}} &= \ket{\beta_{00}}\bra{\beta_{00}} = \frac{1}{2} (\ket{00} + \ket{11})(\bra{00} + \bra{11})\\
			&= \frac{1}{2} (\ket{00}\bra{00} + \ket{00}\bra{11} + \ket{11}\bra{00} + \ket{11}\bra{11})\\
			&= \frac{1}{2} \begin{pmatrix}
				1 & 0 & 0 & 1\\
				0 & 0 & 0 & 0\\
				0 & 0 & 0 & 0\\
				1 & 0 & 0 & 1
			\end{pmatrix}
		\end{align*}
	}
	
\end{frame}

\subsection{Reduced Density Matrix}
\begin{frame}{Reduced Density Matrix}
	Suppose we have a composite quantum system $AB = A \tensor B$, and we want to focus our attention on a state $\ket{\phi} \in AB$ with respect to the subsystem $A$.
	\begin{gather*}
		A = \mathbb{C}^{2^n}\times\mathbb{C}^{2^n}\quad
		B = \mathbb{C}^{2^m}\times\mathbb{C}^{2^m}\\
		AB = (\mathbb{C}^{2^n}\times\mathbb{C}^{2^n})\tensor(\mathbb{C}^{2^m}\times\mathbb{C}^{2^m})
	\end{gather*}
	\vspace*{-2em}
	\begin{align*}
		&Tr_B[\rho] : AB \rightarrow A && Tr_A[\rho] : AB \rightarrow B\\
		&Tr_B[\alpha\tensor\beta] = \alpha \cdot Tr(\beta) &&
		Tr_A[\alpha\tensor\beta] = Tr(\alpha) \cdot \beta
	\end{align*}
	\vspace*{-2em}
	\begin{gather*}
		Tr_S[\rho + \sigma] = Tr_S[\rho] + Tr_S[\sigma] \text{ (Linearity)}
	\end{gather*}
	\begin{center}
		Alternatively:
	\end{center}
	\vspace*{-2em}
	\begin{align*}
		Tr_B[\rho] &= \sum_{v=0}^{2^m} (I_A \tensor \bra{v})\rho(I_A \tensor \ket{v}) && Tr_A[\rho] = \sum_{v=0}^{2^n} (\bra{v} \tensor I_B)\rho(\ket{v} \tensor I_B)
	\end{align*}
	\begin{center}
		Where $v$ labels vectors of an orthonormal basis of the subspace we are tracing out.		
	\end{center}
\end{frame}

% \begin{frame}{Example}
% 	\begin{align*}
% 		Tr_B[\rho] &= \sum_{v=0}^{2^m} (I_A \tensor \bra{v})\rho(I_A \tensor \ket{v}) &&&
% 		\rho_{\beta_{00}} = \frac{1}{2} \begin{pmatrix}
% 			1 & 0 & 0 & 1\\
% 			0 & 0 & 0 & 0\\
% 			0 & 0 & 0 & 0\\
% 			1 & 0 & 0 & 1
% 		\end{pmatrix}
% 	\end{align*}
% 	\begin{align*}
% 		Tr_B[\rho_{\beta_{00}}] =& (I_2\tensor\bra{0})\rho_{\beta_{00}}(I_2\tensor\ket{0}) + (I_2\tensor\bra{1})\rho_{\beta_{00}}(I_2\tensor\ket{1})\\
% 		\only<1>{
% 			=& \frac{1}{2} \begin{pmatrix}
% 				1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0
% 			\end{pmatrix}\begin{pmatrix}
% 				1 & 0 & 0 & 1\\
% 				0 & 0 & 0 & 0\\
% 				0 & 0 & 0 & 0\\
% 				1 & 0 & 0 & 1
% 			\end{pmatrix}\begin{pmatrix}
% 				1 & 0 \\ 0 & 0 \\ 0 & 1 \\ 0 & 0
% 			\end{pmatrix}+\\
% 			&\frac{1}{2} \begin{pmatrix}
% 				0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1
% 			\end{pmatrix}\begin{pmatrix}
% 				1 & 0 & 0 & 1\\
% 				0 & 0 & 0 & 0\\
% 				0 & 0 & 0 & 0\\
% 				1 & 0 & 0 & 1
% 			\end{pmatrix}\begin{pmatrix}
% 				0 & 0 \\ 1 & 0 \\ 0 & 0 \\ 0 & 1
% 			\end{pmatrix}
% 		}
% 		\uncover<2->{
% 			=& \frac{1}{2} \begin{pmatrix}
% 				1 & 0 \\ 0 & 0
% 			\end{pmatrix} + \frac{1}{2} \begin{pmatrix}
% 				0 & 0 \\ 0 & 1
% 			\end{pmatrix}\\
% 		}
% 		\uncover<3->{
% 			=& \frac{1}{2} \begin{pmatrix}
% 				1 & 0 \\ 0 & 1
% 			\end{pmatrix}\\
% 		}
% 		\uncover<4->{
% 			=& \frac{\ket{0}\bra{0} + \ket{1}\bra{1}}{2}\;\\\;\\\;\\\;\\
% 		}
% 	\end{align*}
% \end{frame}

\begin{frame}{Example}
	\begin{gather*}
		A = C^2\times C^2\quad B = C^2\times C^2\quad AB = A\tensor B\\
		\rho_{\beta_{00}} = \ket{\beta_{00}}\bra{\beta_{00}} = \frac{\ket{00}\bra{00} + \ket{00}\bra{11} + \ket{11}\bra{00} + \ket{11}\bra{11}}{2}
	\end{gather*}
	\begin{align*}
		\hspace*{-1cm}
		Tr_B[\rho_{\beta_{00}}] =& \uncover<2->{\frac{\left(Tr_B[\ket{00}\bra{00}] + Tr_b[\ket{00}\bra{11}] + Tr_b[\ket{11}\bra{00}] + Tr_b[\ket{11}\bra{11}]\right)}{2}}\\
		\uncover<3->{=& \frac{(\ket{0}\bra{0} \cdot \braket{0|0}) + (\ket{0}\bra{1} \cdot \braket{0|1}) + (\ket{1}\bra{0} \cdot \braket{1|0}) + (\ket{1}\bra{1} \cdot \braket{1|1})}{2}}\\
		\uncover<4->{=& \frac{\ket{0}\bra{0} + \ket{1}\bra{1}}{2}}
	\end{align*}
\end{frame}

\begin{frame}{Loss of precision}
	\alert{Computing a reduced density matrix \textbf{discards information}!}
	\begin{align*}
		\rho_{\beta_{00}} =& \frac{\ket{00}\bra{00} + \ket{00}\bra{11} + \ket{11}\bra{00} + \ket{11}\bra{11}}{2} & \text{(Pure state)}\\
		\rho_2 =& \frac{\ket{00}\bra{00} + \ket{01}\bra{01} + \ket{10}\bra{10} + \ket{11}\bra{11}}{4} & \text{(Mixed state)}\\\;\\
		\uncover<2->{
			&Tr_B[\rho_{\beta_{00}}] = \frac{\ket{0}\bra{0} + \ket{1}\bra{1}}{2} = Tr_B[\rho_2]
		}
	\end{align*}
	\;\\
	\uncover<2->{
		% A reduced density matrix can be obtained starting from two different states.\\\;\\
		The partial traces of two different initial states can be equal.\\\;\\
		Moreover, for a state $\rho\in A\tensor B$, even if we know $Tr_B[\rho]$ and $Tr_A[\rho]$, we cannot uniquely determine $\rho$. 
	}
\end{frame}

\begin{frame}{Linear Subspaces} %TODO: Work on this
	Each projection $P$ corresponds to a linear subspace $\{v \mid Pv = v\}$.\\
	\;\\
	The support of a matrix $P$	is the subspace orthogonal to its kernel, i.e., the set $\{v \mid Pv \neq 0\}$.
	\;\\
\end{frame}

\section{Abstract Domain}
\begin{frame}{Abstract Domain}
	\begin{gather*}
	\mathcal{D} = \mathbb{C}^{2^n}\tensor\mathbb{C}^{2^n},\quad S = (s_1, ..., s_m),\quad 1 \leq m \leq 2^n,\quad s_i \subseteq [n]\\
		\mathit{AbsDom}(S) = \left\{(P_{s_1}, ..., P_{s_m}) \mid P_{s_i} \text{ is a projection in } \mathbb{C}^{2^{|s_i|}}\tensor\mathbb{C}^{2^{|s_i|}}\right\}
	\end{gather*}
	Intuitively, given a tuple $S$ of sets of qubits, an abstract state $\overline{\sigma} \in \mathit{AbsDom}(S)$ is a tuple of projections over those qubits.\\\;\\
	{\color{blue} Special case:}
	\begin{gather*}
		T = ([n]) \implies \mathit{AbsDom}(T) = \mathcal{D}
	\end{gather*}
\end{frame}

\begin{frame}{Fineness Relation} %TODO: Explain why finer
	Let $S = (s_1, ..., s_m)$ and $T = (t_1, ..., t_m)$ (with $1 \leq m \leq 2^n$), then:
	\begin{equation*}
		\bunder{S \trianglelefteq T}{``T is finer than S''} \triangleq \forall i \in [m].\; s_i \subseteq t_i
	\end{equation*}
	$T$ is ``more concrete'' than S.\\\;\\
	% Minimal elements: tuples $(a_1, ... a_m)$ where all $a_i$ are singleton sets.\\
	Least element: $\bot = (\emptyset, ..., \emptyset)$.\\
	Greatest element: $\top = ([n], ... [n])$.\\
	$\mathit{AbsDom}(\top)$ corresponds to a state so abstract that it holds no information at all.\\ %TODO: Maybe remove?
	$\mathit{AbsDom}(\top)$ corresponds to tuples where every projection is a concrete state.
\end{frame}

\subsection{Abstraction and Concretization Functions}
\begin{frame}{Abstraction Function}
	\vspace*{-2em}
	\begin{gather*}
		S \trianglelefteq T \triangleq \forall i \in [m].\; s_i \subseteq t_i\\
		\alpha_{T \rightarrow S}: \mathit{AbsDom}(T) \rightarrow \mathit{AbsDom}(S)
	\end{gather*}
	\vspace*{-2em}
	\begin{gather*}
		\alpha_{T \rightarrow S}(Q_{t_1}, ..., Q_{t_{m}}) = (P_{s_1}, ..., P_{s_m})\\
		P_{s_i} = \bigcap_{t_j.\; s_i \subseteq t_J} supp(Tr_{t_j \setminus s_i} [Q_{t_j}])
	\end{gather*}
	\\\vspace*{1em}
	Given an abstract state $\overline{\tau} \in \mathit{AbsDom}(T) = (Q_{t_1}, ..., Q_{t_m})$, we want to compute $\overline{\sigma} \in \mathit{AbsDom}(S) = (P_{s_1}, ..., P_{s_m})$. For each $i\in [m]$:
	\begin{enumerate}
		\item Find all $Q_{t_j}$s such that $s_i \subseteq t_j$. We know that at least one exists (for $j=i$), since $S \trianglelefteq T$.
		\item For each $Q_{t_j}$ found, trace out the bits in $t_j$ that are not in $s_i$.
		\item Compute the support of the traced matrices (to preserve the structure of projections).
		\item Compute the intersection of the supports.
	\end{enumerate}
\end{frame}

\begin{frame}{Concretization Function}
	\vspace*{-2em}
	\begin{gather*}
		S \trianglelefteq T \triangleq \forall i \in [m].\; s_i \subseteq t_i\\
		\gamma_{S \rightarrow T}: \mathit{AbsDom}(S) \rightarrow \mathit{AbsDom}(T)
	\end{gather*}
	\vspace*{-2em}
	\begin{gather*}
		\gamma_{S \rightarrow T}(P_{s_1}, ..., P_{s_m}) = (Q_{t_1}, ..., Q_{t_{m}})\\
		Q_{t_j} = \bigcap_{s_i.\; s_i \subseteq t_J} P_{s_i} \tensor I_{t_j \setminus s_i}
	\end{gather*}
	\\\vspace*{1em}
	Given an abstract state $\overline{\sigma} \in \mathit{AbsDom}(S) = (P_{s_1}, ..., P_{s_m})$, we want to compute $\overline{\tau} \in \mathit{AbsDom}(T) = (Q_{t_1}, ..., Q_{t_m})$. For each $j\in [m]$:
	\begin{enumerate}
		\item Find all $P_{s_i}$s such that $s_i \subseteq t_j$. We know at least one exists (for $i=j$), since $S \trianglelefteq T$.
		\item Extend the projection to the space of all qubits in $t_j$, by computing the tensor product with the identity matrix.
		\item Compute the intersection of the extended projections.
	\end{enumerate}
\end{frame}

\begin{frame}{Order Relation on Abstract States}
	\begin{gather*}
		1 \leq m \leq 2^n,\quad S = (s_1, ... s_m),\quad \forall i \in [m].\; s_i \subseteq [n]\\
		\overline{\sigma} \in \mathit{AbsDom}(S) = (P_{s_1}, ..., P_{s_m}),\quad \overline{\tau} \in \mathit{AbsDom}(S) = (Q_{s_1}, ..., Q_{s_m})
	\end{gather*}
	\begin{gather*}
		\overline{\sigma} \sqsubseteq \overline{\tau} \triangleq \forall i \in [m].\; \hspace*{-1.9em}\bunder{P_{s_i} \subseteq Q_{s_i}}{Subspace interpretation\\of projections}
	\end{gather*}
\end{frame}

\begin{frame}{Monotonicity}
	\begin{gather*}
		S \trianglerighteq T\\
		\forall \overline{\sigma}, \overline{\tau} \in \mathit{AbsDom}(T).\; \overline{\sigma} \sqsubseteq \overline{\tau} \implies \alpha_{T\rightarrow S}(\overline{\sigma})\sqsubseteq\alpha_{%TODO: Continue here
		}
	\end{gather*}
\end{frame}

%MARK: Extra
\begin{frame}{Computing the Projection of a Support}
	To compute a projection corresponding to $supp(A)$, we:
	\begin{enumerate}
		\item take the rows $\{r_1, ..., r_n\}$ of A;
		\item extract an orthonormal set of vectors $\{b_1, ..., b_n\}$ that span the same subspace as the rows;
		\item create the matrix $B = \begin{pmatrix}
			b_1 \\ ... \\ b_n
		\end{pmatrix}$;
		\item return $BB^\dagger$.
	\end{enumerate}
\end{frame}

\begin{frame}{Computing the Projection of an Intersection}

    % //    (I \otimes ... \otimes I) -
    % //    supp( k(I \otimes I \times I) - (l.0 + ... + l.(k-1)) )
	\begin{gather*}
		\{P_1, ..., P_k\},\quad \forall i\in [k].\; P_i = C^n \times C^n\\
		\bigcap_{i\in [k]} P_i = I_n - supp(kI_n - \sum_{i\in [k]} P_i)
	\end{gather*}
\end{frame}

% Introduction
% Reasons
% Ingredients
% Density matrices
% Abstract state space
% Galois connections
% Abstract operations
% Assertions
% Conclusions

%TODO: Check computations remembering that qubits are indexed rtl
%TODO: Underline that density matrices are projections
%TODO: Complete explanation of partial traces
%TODO: Maybe remove alternative formula for partial traces
%TODO: Go more into detail with the Linear Subspace frame

\end{document}




% n_{qubits} = 5\\
% \ket{00000}\bra{00000}\\
% % \begin{pmatrix}
% % 	1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
% % 	0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
% % 	0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
% % 	0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
% % 	0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
% % 	0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
% % 	0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
% % 	0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
% % 	0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
% % 	0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
% % 	0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
% % 	0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
% % 	0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
% % 	0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
% % 	0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
% % 	0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
% % \end{pmatrix}